#include "AT91SAM7S256.h"
#include "display.h"
#include "spi.h"

#define   DISPLAY_HEIGHT      64        // Y pixels
#define   DISPLAY_WIDTH       100       // X pixels

#define	  CMD		0
#define	  DAT		1
#define   DISP_LINES    (DISPLAY_HEIGHT/8)

static struct {
  UBYTE   DataArray[DISPLAY_HEIGHT / 8][DISPLAY_WIDTH];
} IOMapDisplay;

UBYTE DisplayInitCommands[] =
{
  0xEB, // LCD bias: 1/9=0xEB
  0x2F, // pump control: set build-in=0x2F
  0xA4, // all pixels: off=0xA4, on=0xA5
  0xA6, // inverse: off=0xA6, on=0xA7
  0x40, // set scroll line: 0=0x40-63=0x7F
  0x81, // set Vbias potentiometer (2-byte command): 0x81 
  0x5A, //      -"-         		             : on=0x5A, off=0x00
  0xC4, // LCD mapping: regular=0xC4, row-mirror=bit 2, col-mirror=bit 3, e.g. col-mirror=0xC2
  0x27, // set temp comp.: -0.20%/C=0x27
  0x29, // panel loading: <=15nF=0x28, >15nF=0x29
  0xA0, // framerate: 76fps=0xA0, 95fps=0xA1
  0x88, // RAM address control: no wrap around+no autoincremet=0x88
  0x23, // set multiplex rate: 1:65=0x23
  0xAF  // set display: on=0xAF, off=0xAE
};

typedef struct
{
  UBYTE   FormatMsb;
  UBYTE   FormatLsb;
  UBYTE   DataBytesMsb;
  UBYTE   DataBytesLsb;
  UBYTE   ItemsX;
  UBYTE   ItemsY;
  UBYTE   ItemPixelsX;
  UBYTE   ItemPixelsY;
  UBYTE   Data[];
} __attribute__((__packed__)) 
FONT, ICON;

const ICON Font = {
  0x04,0x00, // Graphics Format
  0x02,0x40, // Graphics DataSize
  0x10,      // Graphics Count X
  0x06,      // Graphics Count Y
  0x06,      // Graphics Width
  0x08,      // Graphics Height
  {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x5F,0x06,0x00,0x00,0x07,0x03,0x00,0x07,0x03,0x00,0x24,0x7E,0x24,0x7E,0x24,0x00,0x24,0x2B,0x6A,0x12,0x00,0x00,0x63,0x13,0x08,0x64,0x63,0x00,0x30,0x4C,0x52,0x22,0x50,0x00,0x00,0x07,0x03,0x00,0x00,0x00,0x00,0x3E,0x41,0x00,0x00,0x00,0x00,0x41,0x3E,0x00,0x00,0x00,0x08,0x3E,0x1C,0x3E,0x08,0x00,0x08,0x08,0x3E,0x08,0x08,0x00,0x80,0x60,0x60,0x00,0x00,0x00,0x08,0x08,0x08,0x08,0x08,0x00,0x00,0x60,0x60,0x00,0x00,0x00,0x20,0x10,0x08,0x04,0x02,0x00,
  0x3E,0x51,0x49,0x45,0x3E,0x00,0x00,0x42,0x7F,0x40,0x00,0x00,0x62,0x51,0x49,0x49,0x46,0x00,0x22,0x49,0x49,0x49,0x36,0x00,0x18,0x14,0x12,0x7F,0x10,0x00,0x2F,0x49,0x49,0x49,0x31,0x00,0x3C,0x4A,0x49,0x49,0x30,0x00,0x01,0x71,0x09,0x05,0x03,0x00,0x36,0x49,0x49,0x49,0x36,0x00,0x06,0x49,0x49,0x29,0x1E,0x00,0x00,0x6C,0x6C,0x00,0x00,0x00,0x00,0xEC,0x6C,0x00,0x00,0x00,0x08,0x14,0x22,0x41,0x00,0x00,0x24,0x24,0x24,0x24,0x24,0x00,0x00,0x41,0x22,0x14,0x08,0x00,0x02,0x01,0x59,0x09,0x06,0x00,
  0x3E,0x41,0x5D,0x55,0x1E,0x00,0x7E,0x11,0x11,0x11,0x7E,0x00,0x7F,0x49,0x49,0x49,0x36,0x00,0x3E,0x41,0x41,0x41,0x22,0x00,0x7F,0x41,0x41,0x41,0x3E,0x00,0x7F,0x49,0x49,0x49,0x41,0x00,0x7F,0x09,0x09,0x09,0x01,0x00,0x3E,0x41,0x49,0x49,0x7A,0x00,0x7F,0x08,0x08,0x08,0x7F,0x00,0x00,0x41,0x7F,0x41,0x00,0x00,0x30,0x40,0x40,0x40,0x3F,0x00,0x7F,0x08,0x14,0x22,0x41,0x00,0x7F,0x40,0x40,0x40,0x40,0x00,0x7F,0x02,0x04,0x02,0x7F,0x00,0x7F,0x02,0x04,0x08,0x7F,0x00,0x3E,0x41,0x41,0x41,0x3E,0x00,
  0x7F,0x09,0x09,0x09,0x06,0x00,0x3E,0x41,0x51,0x21,0x5E,0x00,0x7F,0x09,0x09,0x19,0x66,0x00,0x26,0x49,0x49,0x49,0x32,0x00,0x01,0x01,0x7F,0x01,0x01,0x00,0x3F,0x40,0x40,0x40,0x3F,0x00,0x1F,0x20,0x40,0x20,0x1F,0x00,0x3F,0x40,0x3C,0x40,0x3F,0x00,0x63,0x14,0x08,0x14,0x63,0x00,0x07,0x08,0x70,0x08,0x07,0x00,0x71,0x49,0x45,0x43,0x00,0x00,0x00,0x7F,0x41,0x41,0x00,0x00,0x02,0x04,0x08,0x10,0x20,0x00,0x00,0x41,0x41,0x7F,0x00,0x00,0x04,0x02,0x01,0x02,0x04,0x00,0x80,0x80,0x80,0x80,0x80,0x00,
  0x00,0x02,0x05,0x02,0x00,0x00,0x20,0x54,0x54,0x54,0x78,0x00,0x7F,0x44,0x44,0x44,0x38,0x00,0x38,0x44,0x44,0x44,0x28,0x00,0x38,0x44,0x44,0x44,0x7F,0x00,0x38,0x54,0x54,0x54,0x08,0x00,0x08,0x7E,0x09,0x09,0x00,0x00,0x18,0x24,0xA4,0xA4,0xFC,0x00,0x7F,0x04,0x04,0x78,0x00,0x00,0x00,0x00,0x7D,0x40,0x00,0x00,0x40,0x80,0x84,0x7D,0x00,0x00,0x7F,0x10,0x28,0x44,0x00,0x00,0x00,0x00,0x7F,0x40,0x00,0x00,0x7C,0x04,0x18,0x04,0x78,0x00,0x7C,0x04,0x04,0x78,0x00,0x00,0x38,0x44,0x44,0x44,0x38,0x00,
  0xFC,0x44,0x44,0x44,0x38,0x00,0x38,0x44,0x44,0x44,0xFC,0x00,0x44,0x78,0x44,0x04,0x08,0x00,0x08,0x54,0x54,0x54,0x20,0x00,0x04,0x3E,0x44,0x24,0x00,0x00,0x3C,0x40,0x20,0x7C,0x00,0x00,0x1C,0x20,0x40,0x20,0x1C,0x00,0x3C,0x60,0x30,0x60,0x3C,0x00,0x6C,0x10,0x10,0x6C,0x00,0x00,0x9C,0xA0,0x60,0x3C,0x00,0x00,0x64,0x54,0x54,0x4C,0x00,0x00,0x08,0x3E,0x41,0x41,0x00,0x00,0x00,0x00,0x77,0x00,0x00,0x00,0x00,0x41,0x41,0x3E,0x08,0x00,0x02,0x01,0x02,0x01,0x00,0x00,0x10,0x20,0x40,0x38,0x07,0x00}
};

UBYTE DisplayLineString[DISP_LINES][3] =
{
  { 0xB0,0x10,0x00 },
  { 0xB1,0x10,0x00 },
  { 0xB2,0x10,0x00 },
  { 0xB3,0x10,0x00 },
  { 0xB4,0x10,0x00 },
  { 0xB5,0x10,0x00 },
  { 0xB6,0x10,0x00 },
  { 0xB7,0x10,0x00 }
};

void  DisplayInit(void) { 
  SPIInit(); 
  DisplayInitCommands[6]  = 0x5A;\
	DisplayInitCommands[13] = 0xAF;\
}

void  DisplayExit(void) { ; }

void  DisplaySetPixel(UBYTE X,UBYTE Y)
{
  if ((X < DISPLAY_WIDTH) && (Y < DISPLAY_HEIGHT))
  {
    IOMapDisplay.DataArray[(Y / 8)][X] |= (1 << (Y % 8));
  }
}

void  DisplayClrPixel(UBYTE X,UBYTE Y)
{
  if ((X < DISPLAY_WIDTH) && (Y < DISPLAY_HEIGHT))
  {
    IOMapDisplay.DataArray[(Y / 8)][X] &= ~(1 << (Y % 8));
  }
}

UBYTE DisplayWrite(UBYTE Type,UBYTE *pData,UBYTE Length)
{
  UBYTE Result = FALSE;

  if(SPITxReady())
  {
    if (Type)
    {
      SPIPIOSetData();
    }
    else
    {
      SPIPIOClearData();
    }
    SPIWrite(pData,Length);
    Result = TRUE;
  }  

  return (Result);
}

void DisplayUpdateSync(void)
{
  UWORD State = 0;
  UWORD Line = 0;
  UBYTE *pImage = (UBYTE*)IOMapDisplay.DataArray;
  UWORD Height = DISPLAY_HEIGHT;
  UWORD Width = DISPLAY_WIDTH;
  UWORD quit = 0;
  while(!quit) {
    switch (State) {
      case 0:
        if (DisplayWrite(CMD,(UBYTE*)DisplayInitCommands,sizeof(DisplayInitCommands)) == TRUE) {
          State++;
        }
        break;
      default:
        if ((State & 1)) {
          if (DisplayWrite(CMD,(UBYTE*)DisplayLineString[Line],3) == TRUE) {
            State++;
          }
        }
        else {
          if (DisplayWrite(DAT,(UBYTE*)&pImage[Line * Width],DISPLAY_WIDTH) == TRUE) {
            State++;
            if (++Line >= (Height / 8)) {
              State = 0;
              quit = 1; break;
            }
          }
        }
    }
  }
  return;
}

void  DisplayLineX(UBYTE X1,UBYTE X2,UBYTE Y)
{
  UBYTE X;

  for(X = X1;X < X2;X++)
  {
    IOMapDisplay.DataArray[(Y / 8)][X] |= (1 << (Y % 8));
  }
}

void  DisplayLineY(UBYTE X,UBYTE Y1,UBYTE Y2)
{
  UBYTE Y;

  for(Y = Y1;Y < Y2;Y++)
  {
    IOMapDisplay.DataArray[(Y / 8)][X] |= (1 << (Y % 8));
  }
}

void DisplayEraseLine(UBYTE Line)
{
  UBYTE Tmp;

  for(Tmp = 0;Tmp < DISPLAY_WIDTH;Tmp++)
  {
    IOMapDisplay.DataArray[Line][Tmp] = 0x00;
  }
}

void DisplayErase(void)
{
  UBYTE Tmp;

  for(Tmp = 0;Tmp < (DISPLAY_HEIGHT / 8);Tmp++)
  {
    DisplayEraseLine(Tmp);
  }
}

void DisplayChar(UBYTE X,UBYTE Y,UBYTE Char)
{
  UBYTE *pSource;
  UBYTE FontWidth;
  UBYTE FontHeight;
  UBYTE Items;
  UBYTE Item;
  UBYTE TmpY;
  const ICON *pFont = &Font;

  Items = pFont->ItemsX * pFont->ItemsY;
  Item = Char - ' ';
  if(Item < Items)
  {
    FontWidth = pFont->ItemPixelsX;
    pSource = (UBYTE*)&pFont->Data[Item * FontWidth];
    while (FontWidth--)
    {
      TmpY = 0;
      FontHeight = pFont->ItemPixelsY;
      while(FontHeight--)
      {
        if(((*pSource) & (1 << TmpY)))
        {
          DisplaySetPixel(X,Y + TmpY);
        }
        else
        {
          DisplayClrPixel(X,Y + TmpY);
        }
        TmpY++;
      }
      X++;
      pSource++;
    }
  }
}

void DisplayNum(UBYTE X,UBYTE Y,ULONG Num)
{	
  ULONG t1=0;
  UBYTE t2=0,ch=0;
  static UBYTE digits=0,i=0;
  t1=Num;
  t2=t1%10;
  t1=(t1-t2)/10;
  if(t1>0){
	  digits++;
    DisplayNum(X,Y,t1);
  } 
  else {
	  i=digits;
  }
  ch='0'+t2;
  DisplayChar(X+(6*(digits-i--)),Y,ch);    
}

void DisplayString(UBYTE X,UBYTE Y,UBYTE *pString)
{ 
  while(*pString){
    DisplayChar(X,Y,*pString);
    pString++;
    X=X+6;
    if(X>DISPLAY_WIDTH-6){
      X = 0 ; 
      Y = Y +8;
    }
  }
}

void printtime(UBYTE hh, UBYTE mm, UBYTE ss){
  char a = ':';
  DisplayNum((UBYTE)55,(UBYTE)55,(UWORD)hh);
  DisplayChar((UBYTE)61,(UBYTE)55,(UBYTE)a);
  DisplayNum((UBYTE)67,(UBYTE)55,(UWORD)mm);
  DisplayChar((UBYTE)79,(UBYTE)55,(UBYTE)a);
  DisplayNum((UBYTE)85,(UBYTE)55,(UWORD)ss);
}
